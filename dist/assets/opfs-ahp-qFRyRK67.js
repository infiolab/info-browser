import{c as L,R as m,T as r,h as a,p as J,a as U,x as I,U as H,__tla as $}from"../background.js";let C,q=Promise.all([(()=>{try{return $}catch{}})()]).then(async()=>{U();let A,R,D,T,M,O,j,w,k,y,x,E,b,S,l,z,F,N,g,f,_,v,W;A="state.txt",R="data",D={DIR:16384,FILE:32768},C=class extends L{constructor(t,{initialPoolSize:e=1e3,maintainedPoolSize:s=100,debug:i=!1}={}){super(t,{debug:i}),m(this,l),m(this,T),m(this,M),m(this,O),m(this,j),m(this,w),m(this,k,new Map),m(this,y,new Map),m(this,x,0),m(this,E,new Map),m(this,b,new Map),this.lastCheckpoint=0,this.checkpointInterval=1e3*60,this.poolCounter=0,m(this,S,new Set),this.initialPoolSize=e,this.maintainedPoolSize=s}async init(t,e){return await r(this,l,z).call(this),super.init(t,e)}async syncToFs(t=!1){await this.maybeCheckpointState(),await this.maintainPool(),t||this.flush()}async closeFs(){for(let t of a(this,y).values())t.close();a(this,w).flush(),a(this,w).close(),this.pg.Module.FS.quit()}async maintainPool(t){t=t||this.maintainedPoolSize;let e=t-this.state.pool.length,s=[];for(let i=0;i<e;i++)s.push(new Promise(async o=>{++this.poolCounter;let h=`${(Date.now()-1704063600).toString(16).padStart(8,"0")}-${this.poolCounter.toString(16).padStart(8,"0")}`,c=await a(this,O).getFileHandle(h,{create:!0}),p=await c.createSyncAccessHandle();a(this,k).set(h,c),a(this,y).set(h,p),r(this,l,N).call(this,{opp:"createPoolFile",args:[h]}),this.state.pool.push(h),o()}));for(let i=0;i>e;i--)s.push(new Promise(async o=>{let h=this.state.pool.pop();r(this,l,N).call(this,{opp:"deletePoolFile",args:[h]});let c=a(this,k).get(h);a(this,y).get(h)?.close(),await a(this,O).removeEntry(c.name),a(this,k).delete(h),a(this,y).delete(h),o()}));await Promise.all(s)}_createPoolFileState(t){this.state.pool.push(t)}_deletePoolFileState(t){let e=this.state.pool.indexOf(t);e>-1&&this.state.pool.splice(e,1)}async maybeCheckpointState(){Date.now()-this.lastCheckpoint>this.checkpointInterval&&await this.checkpointState()}async checkpointState(){let t=new TextEncoder().encode(JSON.stringify(this.state));a(this,w).truncate(0),a(this,w).write(t,{at:0}),a(this,w).flush(),this.lastCheckpoint=Date.now()}flush(){for(let t of a(this,S))try{t.flush()}catch{}a(this,S).clear()}chmod(t,e){r(this,l,F).call(this,{opp:"chmod",args:[t,e]},()=>{this._chmodState(t,e)})}_chmodState(t,e){let s=r(this,l,f).call(this,t);s.mode=e}close(t){let e=r(this,l,_).call(this,t);a(this,E).delete(t),a(this,b).delete(e)}fstat(t){let e=r(this,l,_).call(this,t);return this.lstat(e)}lstat(t){let e=r(this,l,f).call(this,t),s=e.type==="file"?a(this,y).get(e.backingFilename).getSize():0,i=4096;return{dev:0,ino:0,mode:e.mode,nlink:1,uid:0,gid:0,rdev:0,size:s,blksize:i,blocks:Math.ceil(s/i),atime:e.lastModified,mtime:e.lastModified,ctime:e.lastModified}}mkdir(t,e){r(this,l,F).call(this,{opp:"mkdir",args:[t,e]},()=>{this._mkdirState(t,e)})}_mkdirState(t,e){let s=r(this,l,g).call(this,t),i=s.pop(),o=[],h=this.state.root;for(let p of s){if(o.push(t),!Object.prototype.hasOwnProperty.call(h.children,p))if(e?.recursive)this.mkdir(o.join("/"));else throw new d("ENOENT","No such file or directory");if(h.children[p].type!=="directory")throw new d("ENOTDIR","Not a directory");h=h.children[p]}if(Object.prototype.hasOwnProperty.call(h.children,i))throw new d("EEXIST","File exists");let c={type:"directory",lastModified:Date.now(),mode:e?.mode||D.DIR,children:{}};h.children[i]=c}open(t,e,s){if(r(this,l,f).call(this,t).type!=="file")throw new d("EISDIR","Is a directory");let i=r(this,l,v).call(this);return a(this,E).set(i,t),a(this,b).set(t,i),i}readdir(t){let e=r(this,l,f).call(this,t);if(e.type!=="directory")throw new d("ENOTDIR","Not a directory");return Object.keys(e.children)}read(t,e,s,i,o){let h=r(this,l,_).call(this,t),c=r(this,l,f).call(this,h);if(c.type!=="file")throw new d("EISDIR","Is a directory");return a(this,y).get(c.backingFilename).read(new Uint8Array(e.buffer,s,i),{at:o})}rename(t,e){r(this,l,F).call(this,{opp:"rename",args:[t,e]},()=>{this._renameState(t,e,!0)})}_renameState(t,e,s=!1){let i=r(this,l,g).call(this,t),o=i.pop(),h=r(this,l,f).call(this,i.join("/"));if(!Object.prototype.hasOwnProperty.call(h.children,o))throw new d("ENOENT","No such file or directory");let c=r(this,l,g).call(this,e),p=c.pop(),n=r(this,l,f).call(this,c.join("/"));if(s&&Object.prototype.hasOwnProperty.call(n.children,p)){let u=n.children[p];a(this,y).get(u.backingFilename).truncate(0),this.state.pool.push(u.backingFilename)}n.children[p]=h.children[o],delete h.children[o]}rmdir(t){r(this,l,F).call(this,{opp:"rmdir",args:[t]},()=>{this._rmdirState(t)})}_rmdirState(t){let e=r(this,l,g).call(this,t),s=e.pop(),i=r(this,l,f).call(this,e.join("/"));if(!Object.prototype.hasOwnProperty.call(i.children,s))throw new d("ENOENT","No such file or directory");let o=i.children[s];if(o.type!=="directory")throw new d("ENOTDIR","Not a directory");if(Object.keys(o.children).length>0)throw new d("ENOTEMPTY","Directory not empty");delete i.children[s]}truncate(t,e=0){let s=r(this,l,f).call(this,t);if(s.type!=="file")throw new d("EISDIR","Is a directory");let i=a(this,y).get(s.backingFilename);if(!i)throw new d("ENOENT","No such file or directory");i.truncate(e),a(this,S).add(i)}unlink(t){r(this,l,F).call(this,{opp:"unlink",args:[t]},()=>{this._unlinkState(t,!0)})}_unlinkState(t,e=!1){let s=r(this,l,g).call(this,t),i=s.pop(),o=r(this,l,f).call(this,s.join("/"));if(!Object.prototype.hasOwnProperty.call(o.children,i))throw new d("ENOENT","No such file or directory");let h=o.children[i];if(h.type!=="file")throw new d("EISDIR","Is a directory");if(delete o.children[i],e){let c=a(this,y).get(h.backingFilename);c?.truncate(0),a(this,S).add(c),a(this,b).has(t)&&(a(this,E).delete(a(this,b).get(t)),a(this,b).delete(t))}this.state.pool.push(h.backingFilename)}utimes(t,e,s){r(this,l,F).call(this,{opp:"utimes",args:[t,e,s]},()=>{this._utimesState(t,e,s)})}_utimesState(t,e,s){let i=r(this,l,f).call(this,t);i.lastModified=s}writeFile(t,e,s){let i=r(this,l,g).call(this,t),o=i.pop(),h=r(this,l,f).call(this,i.join("/"));if(Object.prototype.hasOwnProperty.call(h.children,o)){let n=h.children[o];n.lastModified=Date.now(),r(this,l,N).call(this,{opp:"setLastModified",args:[t,n.lastModified]})}else{if(this.state.pool.length===0)throw new Error("No more file handles available in the pool");let n={type:"file",lastModified:Date.now(),mode:s?.mode||D.FILE,backingFilename:this.state.pool.pop()};h.children[o]=n,r(this,l,N).call(this,{opp:"createFileNode",args:[t,n]})}let c=h.children[o],p=a(this,y).get(c.backingFilename);e.length>0&&(p.write(typeof e=="string"?new TextEncoder().encode(e):new Uint8Array(e),{at:0}),t.startsWith("/pg_wal")&&a(this,S).add(p))}_createFileNodeState(t,e){let s=r(this,l,g).call(this,t),i=s.pop(),o=r(this,l,f).call(this,s.join("/"));o.children[i]=e;let h=this.state.pool.indexOf(e.backingFilename);return h>-1&&this.state.pool.splice(h,1),e}_setLastModifiedState(t,e){let s=r(this,l,f).call(this,t);s.lastModified=e}write(t,e,s,i,o){let h=r(this,l,_).call(this,t),c=r(this,l,f).call(this,h);if(c.type!=="file")throw new d("EISDIR","Is a directory");let p=a(this,y).get(c.backingFilename);if(!p)throw new d("EBADF","Bad file descriptor");let n=p.write(new Uint8Array(e,s,i),{at:o});return h.startsWith("/pg_wal")&&a(this,S).add(p),n}},T=new WeakMap,M=new WeakMap,O=new WeakMap,j=new WeakMap,w=new WeakMap,k=new WeakMap,y=new WeakMap,x=new WeakMap,E=new WeakMap,b=new WeakMap,S=new WeakMap,l=new WeakSet,z=async function(){I(this,T,await navigator.storage.getDirectory()),I(this,M,await r(this,l,W).call(this,this.dataDir,{create:!0})),I(this,O,await r(this,l,W).call(this,R,{from:a(this,M),create:!0})),I(this,j,await a(this,M).getFileHandle(A,{create:!0})),I(this,w,await a(this,j).createSyncAccessHandle());let t=new ArrayBuffer(a(this,w).getSize());a(this,w).read(t,{at:0});let e,s=new TextDecoder().decode(t).split(`
`),i=!1;try{e=JSON.parse(s[0])}catch{e={root:{type:"directory",lastModified:Date.now(),mode:D.DIR,children:{}},pool:[]},a(this,w).truncate(0),a(this,w).write(new TextEncoder().encode(JSON.stringify(e)),{at:0}),i=!0}this.state=e;let o=s.slice(1).filter(Boolean).map(n=>JSON.parse(n));for(let n of o){let u=`_${n.opp}State`;if(typeof this[u]=="function")try{this[u].bind(this)(...n.args)}catch(P){console.warn("Error applying OPFS AHP WAL entry",n,P)}}let h=[],c=async n=>{if(n.type==="file")try{let u=await a(this,O).getFileHandle(n.backingFilename),P=await u.createSyncAccessHandle();a(this,k).set(n.backingFilename,u),a(this,y).set(n.backingFilename,P)}catch(u){console.error("Error opening file handle for node",n,u)}else for(let u of Object.values(n.children))h.push(c(u))};await c(this.state.root);let p=[];for(let n of this.state.pool)p.push(new Promise(async u=>{a(this,k).has(n)&&console.warn("File handle already exists for pool file",n);let P=await a(this,O).getFileHandle(n),B=await P.createSyncAccessHandle();a(this,k).set(n,P),a(this,y).set(n,B),u()}));await Promise.all([...h,...p]),await this.maintainPool(i?this.initialPoolSize:this.maintainedPoolSize)},F=function(t,e){let s=r(this,l,N).call(this,t);try{e()}catch(i){throw a(this,w).truncate(s),i}},N=function(t){let e=JSON.stringify(t),s=new TextEncoder().encode(`
${e}`),i=a(this,w).getSize();return a(this,w).write(s,{at:i}),a(this,S).add(a(this,w)),i},g=function(t){return t.split("/").filter(Boolean)},f=function(t,e){let s=r(this,l,g).call(this,t),i=e||this.state.root;for(let o of s){if(i.type!=="directory")throw new d("ENOTDIR","Not a directory");if(!Object.prototype.hasOwnProperty.call(i.children,o))throw new d("ENOENT","No such file or directory");i=i.children[o]}return i},_=function(t){let e=a(this,E).get(t);if(!e)throw new d("EBADF","Bad file descriptor");return e},v=function(){let t=++H(this,x)._;for(;a(this,E).has(t);)H(this,x)._++;return t},W=async function(t,e){let s=r(this,l,g).call(this,t),i=e?.from||a(this,T);for(let o of s)i=await i.getDirectoryHandle(o,{create:e?.create});return i};var d=class extends Error{constructor(t,e){super(e),typeof t=="number"?this.code=t:typeof t=="string"&&(this.code=J[t])}}});export{C as OpfsAhpFS,q as __tla};
